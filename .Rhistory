#'     id <- dataviewer(mtcars, iris)
#'     stop_dataviewer(id)
#' }
#'
#' @export
dataviewer <- function(..., background = NULL, port = NULL) {
# Capture datasets
datasets <- list(...)
dataset_names <- as.character(substitute(list(...)))[-1]
# RULE: If no datasets provided, force background = FALSE
if (length(datasets) == 0) {
if (!is.null(background) && background == TRUE) {
message("Note: Background mode cannot access Global Environment for import.")
}
background <- FALSE
message("Using foreground mode.")
} else {
# If datasets provided and background not specified, default to TRUE
if (is.null(background)) {
background <- TRUE
}
}
# Determine if import panel should be shown
# Show import panel only when: background=FALSE OR no datasets provided
show_import_panel <- !background
# If background mode, launch in separate process
if (background) {
if (!requireNamespace("callr", quietly = TRUE)) {
stop("Package 'callr' is required for background mode. Install with: install.packages('callr')")
}
# Generate unique ID for this process
.dataviewer_env$counter <- .dataviewer_env$counter + 1L
proc_id <- paste0("dv_", .dataviewer_env$counter)
# Generate a port if not specified
if (is.null(port)) {
port <- sample(3000:8000, 1)
}
message("Starting dataviewer in background on port ", port, "...")
# Launch in background WITHOUT opening browser
# IMPORTANT: Pass the entire app creation code as a function
proc <- callr::r_bg(
func = function(datasets, dataset_names, port, show_import_panel) {
# Load required packages in background session
library(dataviewR)
# Calling the internal functions so the background process can see them
dataviewer_ui_head    <- utils::getFromNamespace("dataviewer_ui_head", "dataviewR")
dataviewer_tab_ui     <- utils::getFromNamespace("dataviewer_tab_ui", "dataviewR")
dataviewer_tab_server <- utils::getFromNamespace("dataviewer_tab_server", "dataviewR")
# Determine trigger mode
if (length(datasets) == 0) {
cat("\033[34mNote: Showing the Import Dataset Panel because no datasets were provided\033[0m\n")
trigger <- 1
initial_datasets <- list()
initial_names <- character()
} else {
valid_data <- sapply(datasets, function(d) any(class(d) %in% c("tbl_df", "tbl", "data.frame")))
if (!all(valid_data)) {
stop("All arguments must be tibbles or data.frames")
}
cat("\033[34mNote:", length(datasets), "dataset(s) provided\033[0m\n")
trigger <- 2
initial_datasets <- datasets
initial_names <- dataset_names
}
app <- shiny::shinyApp(
ui = shiny::fluidPage(
class = "full-width",
shinyjs::useShinyjs(),
dataviewer_ui_head(),
shiny::tabsetPanel(
id = "opt",
# Conditionally show Import Dataset panel
if (show_import_panel) {
shiny::tabPanel(
"Import Dataset",
value = "import_tab",
shiny::fluidRow(datamods::import_globalenv_ui("myid"))
)
}
)
),
server = function(input, output, session) {
dataset_store <- shiny::reactiveValues()
tab_counter <- shiny::reactiveVal(0)
create_tab_id <- function(name) {
paste0("tab_", tolower(gsub("[^a-zA-Z0-9]", "_", name)), "_", tab_counter())
}
# FIXED: create_viewer_tab with local() to capture tab_id correctly
create_viewer_tab <- function(tab_id, dataset_name, dataset, show_close_btn = TRUE) {
tab_title <- if (show_close_btn) {
shiny::tagList(
tolower(dataset_name),
shiny::tags$span(
class = "close-tab-btn",
onclick = sprintf("Shiny.setInputValue('close_tab', '%s', {priority: 'event'})", tab_id),
"x"
)
)
} else {
tolower(dataset_name)
}
shiny::appendTab(
inputId = "opt",
shiny::tabPanel(
title = tab_title,
value = tab_id,
dataviewer_tab_ui(tab_id)
),
select = TRUE
)
dataset_store[[tab_id]] <- list(
data = dataset,
name = dataset_name
)
# FIX: Use local() to capture tab_id correctly
local({
current_tab_id <- tab_id
dataviewer_tab_server(
id = current_tab_id,
get_data = shiny::reactive(dataset_store[[current_tab_id]]$data),
dataset_name = shiny::reactive(dataset_store[[current_tab_id]]$name)
)
})
}
if (trigger == 2) {
session$onFlushed(function() {
for (i in seq_along(initial_datasets)) {
shiny::isolate({
tab_counter(tab_counter() + 1)
tab_id <- create_tab_id(initial_names[i])
create_viewer_tab(tab_id, initial_names[i], initial_datasets[[i]], show_close_btn = TRUE)
})
}
}, once = TRUE)
}
# Only set up import handlers if import panel is shown
if (show_import_panel) {
imported <- datamods::import_globalenv_server("myid", btn_show_data = FALSE)
shiny::observeEvent(input$`myid-confirm`, {
shiny::req(imported$data())
dataset_name <- imported$name()
dataset <- imported$data()
if (length(names(dataset_store)) > 0) {
existing_tabs <- sapply(names(dataset_store), function(tid) {
if (is.null(dataset_store[[tid]])) return(FALSE)
dataset_store[[tid]]$name == dataset_name
}, USE.NAMES = FALSE)
existing_tabs <- as.logical(existing_tabs)
} else {
existing_tabs <- logical(0)
}
if (length(existing_tabs) > 0 && any(existing_tabs, na.rm = TRUE)) {
valid_tab_ids <- names(dataset_store)[!sapply(dataset_store, is.null)]
existing_tab_id <- valid_tab_ids[which(existing_tabs)[1]]
if(!is.null(existing_tab_id) && !is.na(existing_tab_id)) {
shiny::updateTabsetPanel(session, "opt", selected = existing_tab_id)
shiny::showNotification(paste("Switched to existing tab:", dataset_name), type = "message")
}
} else {
shiny::isolate({
tab_counter(tab_counter() + 1)
tab_id <- create_tab_id(dataset_name)
create_viewer_tab(tab_id, dataset_name, dataset, show_close_btn = TRUE)
})
}
})
}
shiny::observeEvent(input$close_tab, {
tab_id <- input$close_tab
shiny::removeTab(inputId = "opt", target = tab_id)
dataset_store[[tab_id]] <- NULL
# CHANGED: Switch to first tab instead of always import_tab
all_tabs <- names(dataset_store)[!sapply(dataset_store, is.null)]
if (length(all_tabs) > 0) {
# Switch to first dataset tab
shiny::updateTabsetPanel(session, "opt", selected = all_tabs[1])
} else if (show_import_panel) {
# If no dataset tabs left and import panel exists, go there
shiny::updateTabsetPanel(session, "opt", selected = "import_tab")
}
})
}
)
shiny::runApp(app, port = port, launch.browser = FALSE)
},
args = list(datasets = datasets, dataset_names = dataset_names, port = port, show_import_panel = show_import_panel),
supervise = TRUE,
stdout = "|",
stderr = "|"
)
# Store process
.dataviewer_env$processes[[proc_id]] <- list(
process = proc,
started = Sys.time(),
data_names = if (length(dataset_names) > 0) paste(dataset_names, collapse = ", ") else "<import mode>",
port = port
)
# Wait a moment for app to initialize
Sys.sleep(1.5)
# Check if process is alive
if (!proc$is_alive()) {
error_msg <- tryCatch(proc$read_all_error_lines(), error = function(e) "Could not read error")
output_msg <- tryCatch(proc$read_all_output_lines(), error = function(e) "Could not read output")
stop("Failed to start dataviewer in background.\n",
"Exit status: ", proc$get_exit_status(), "\n",
"Error output:\n", paste(error_msg, collapse = "\n"), "\n",
"Standard output:\n", paste(output_msg, collapse = "\n"))
}
# Open in RStudio Viewer pane from MAIN process
url <- paste0("http://127.0.0.1:", port)
if (requireNamespace("rstudioapi", quietly = TRUE) &&
rstudioapi::isAvailable() &&
rstudioapi::hasFun("viewer")) {
rstudioapi::viewer(url)
message("Opening in RStudio Viewer pane")
} else {
utils::browseURL(url)
message("Opening in browser")
}
message("Dataviewer running in background (ID: ", proc_id, ")")
message("URL: ", url)
if (length(dataset_names) > 0) {
message("Datasets: ", paste(dataset_names, collapse = ", "))
}
message("Use stop_dataviewer('", proc_id, "') to stop this viewer")
message("Use list_dataviewers() to see all running viewers")
return(invisible(proc_id))
}
# Original foreground mode
# Determine trigger mode
if (length(datasets) == 0) {
cat("\033[34mNote: Showing the Import Dataset Panel because no datasets were provided\033[0m\n")
trigger <- 1  # triggers the import dataset panel
initial_datasets <- list()
initial_names <- character()
} else {
# Validate all inputs are data.frame/tibble
valid_data <- sapply(datasets, function(d) any(class(d) %in% c("tbl_df", "tbl", "data.frame")))
if (!all(valid_data)) {
stop("All arguments must be tibbles or data.frames")
}
cat("\033[34mNote:", length(datasets), "dataset(s) provided\033[0m\n")
trigger <- 2  # Shows passed dataframes
initial_datasets <- datasets
initial_names <- dataset_names
}
shiny::shinyApp(
# --- REFACTORED UI ---
ui = shiny::fluidPage(
class = "full-width",
shinyjs::useShinyjs(),
dataviewer_ui_head(), # Call UI head helper
shiny::tabsetPanel(
id = "opt",
# Conditionally show Import Dataset panel
if (show_import_panel) {
shiny::tabPanel(
"Import Dataset",
value = "import_tab",
shiny::fluidRow(datamods::import_globalenv_ui("myid"))
)
}
)
),
# --- REFACTORED SERVER ---
server = function(input, output, session) {
# Reactive values to store dataset information
dataset_store <- shiny::reactiveValues()
tab_counter <- shiny::reactiveVal(0)
# Helper function to create unique tab ID
create_tab_id <- function(name) {
paste0("tab_", tolower(gsub("[^a-zA-Z0-9]", "_", name)), "_", tab_counter())
}
# Helper function to create viewer tab
# FIXED: Uses local() to properly capture tab_id
create_viewer_tab <- function(tab_id, dataset_name, dataset, show_close_btn = TRUE) {
# Create tab title with or without close button
tab_title <- if (show_close_btn) {
shiny::tagList(
tolower(dataset_name),
shiny::tags$span(
class = "close-tab-btn",
onclick = sprintf("Shiny.setInputValue('close_tab', '%s', {priority: 'event'})", tab_id),
"x"
)
)
} else {
tolower(dataset_name)
}
# Append the new tab using the Module UI
shiny::appendTab(
inputId = "opt",
shiny::tabPanel(
title = tab_title,
value = tab_id,
dataviewer_tab_ui(tab_id) # Call Module UI
),
select = TRUE
)
# Store dataset in reactive values
dataset_store[[tab_id]] <- list(
data = dataset,
name = dataset_name
)
# FIX: Use local() to capture tab_id correctly
local({
# Create a local copy of tab_id that won't be affected by loop iterations
current_tab_id <- tab_id
# Call the Module Server with properly scoped reactives
dataviewer_tab_server(
id = current_tab_id,
get_data = shiny::reactive(dataset_store[[current_tab_id]]$data),
dataset_name = shiny::reactive(dataset_store[[current_tab_id]]$name)
)
})
}
# Initialize tabs with provided datasets (trigger == 2)
if (trigger == 2) {
session$onFlushed(function() {
for (i in seq_along(initial_datasets)) {
shiny::isolate({
tab_counter(tab_counter() + 1)
tab_id <- create_tab_id(initial_names[i])
create_viewer_tab(tab_id, initial_names[i], initial_datasets[[i]], show_close_btn = TRUE)
})
}
}, once = TRUE)
}
# Only set up import handlers if import panel is shown
if (show_import_panel) {
imported <- datamods::import_globalenv_server("myid", btn_show_data = FALSE)
shiny::observeEvent(input$`myid-confirm`, {
shiny::req(imported$data())
dataset_name <- imported$name()
dataset <- imported$data()
# Check if dataset already exists
if (length(names(dataset_store)) > 0) {
existing_tabs <- sapply(names(dataset_store), function(tid) {
# Check for NULLs which can happen during tab removal
if (is.null(dataset_store[[tid]])) return(FALSE)
dataset_store[[tid]]$name == dataset_name
}, USE.NAMES = FALSE)
existing_tabs <- as.logical(existing_tabs)
} else {
existing_tabs <- logical(0)
}
if (length(existing_tabs) > 0 && any(existing_tabs, na.rm = TRUE)) {
# Switch to existing tab
valid_tab_ids <- names(dataset_store)[!sapply(dataset_store, is.null)]
existing_tab_id <- valid_tab_ids[which(existing_tabs)[1]]
if(!is.null(existing_tab_id) && !is.na(existing_tab_id)) {
shiny::updateTabsetPanel(session, "opt", selected = existing_tab_id)
shiny::showNotification(paste("Switched to existing tab:", dataset_name), type = "message")
}
} else {
# Create new tab (always show close button)
shiny::isolate({
tab_counter(tab_counter() + 1)
tab_id <- create_tab_id(dataset_name)
create_viewer_tab(tab_id, dataset_name, dataset, show_close_btn = TRUE)
})
}
})
}
# Handle tab closing
shiny::observeEvent(input$close_tab, {
tab_id <- input$close_tab
# Remove tab
shiny::removeTab(inputId = "opt", target = tab_id)
# Remove from storage
dataset_store[[tab_id]] <- NULL
# Switch to first tab when a tab has been closed
all_tabs <- names(dataset_store)[!sapply(dataset_store, is.null)]
if (length(all_tabs) > 0) {
# Switch to first dataset tab
shiny::updateTabsetPanel(session, "opt", selected = all_tabs[1])
} else if (show_import_panel) {
# If no dataset tabs left and import panel exists, go there
shiny::updateTabsetPanel(session, "opt", selected = "import_tab")
}
})
}
)
}
#' List Active Background Dataviewer Processes
#'
#' @export
list_dataviewers <- function() {
if (length(.dataviewer_env$processes) == 0) {
message("No background dataviewer processes are running.")
return(invisible(NULL))
}
cat("Active background dataviewer processes:\n")
cat("=======================================\n\n")
for (id in names(.dataviewer_env$processes)) {
proc_info <- .dataviewer_env$processes[[id]]
proc <- proc_info$process
status <- if (proc$is_alive()) "RUNNING" else "STOPPED"
data_info <- paste0("Data: ", proc_info$data_names)
port_info <- if (!is.null(proc_info$port)) {
paste0("Port: ", proc_info$port)
} else {
"Port: auto"
}
started_info <- paste0("Started: ", format(proc_info$started, "%Y-%m-%d %H:%M:%S"))
cat("ID: ", id, "\n", sep = "")
cat("  Status: ", status, "\n", sep = "")
cat("  ", data_info, "\n", sep = "")
cat("  ", port_info, "\n", sep = "")
cat("  ", started_info, "\n", sep = "")
cat("\n")
}
invisible(NULL)
}
#' Stop All Background Dataviewer Processes
#'
#' @export
stop_all_dataviewers <- function() {
if (length(.dataviewer_env$processes) == 0) {
message("No background dataviewer processes are running.")
return(invisible(NULL))
}
count <- 0
for (id in names(.dataviewer_env$processes)) {
proc_info <- .dataviewer_env$processes[[id]]
proc <- proc_info$process
if (proc$is_alive()) {
proc$kill()
count <- count + 1
}
}
# Clear all processes
.dataviewer_env$processes <- list()
message("Stopped ", count, " dataviewer process", if (count != 1) "es" else "")
invisible(NULL)
}
#' Stop a Specific or Most Recent Dataviewer Process
#'
#' @param id Character string specifying the process ID to stop. If NULL, stops the most recent background dataviewer.
#'
#' @export
stop_dataviewer <- function(id = NULL) {
# If no ID specified and no processes running, just message and return
if (is.null(id) && length(.dataviewer_env$processes) == 0) {
message("No background dataviewer processes are running.")
return(invisible(NULL))
}
# If no ID specified, use the most recent process
if (is.null(id)) {
id <- names(.dataviewer_env$processes)[length(.dataviewer_env$processes)]
message("Stopping most recent dataviewer: ", id)
}
# Check if process exists - throw error if specific ID not found
if (!id %in% names(.dataviewer_env$processes)) {
if (length(.dataviewer_env$processes) == 0) {
stop("Process '", id, "' not found. No background dataviewer processes are running.")
} else {
available <- paste(names(.dataviewer_env$processes), collapse = ", ")
stop("Process '", id, "' not found. Available processes: ", available)
}
}
# Get the process
proc_info <- .dataviewer_env$processes[[id]]
proc <- proc_info$process
# Kill the process
if (proc$is_alive()) {
proc$kill()
message("Stopped dataviewer process: ", id)
} else {
message("Process ", id, " was already stopped.")
}
# Remove from list
.dataviewer_env$processes[[id]] <- NULL
invisible(NULL)
}
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::clean_site()
pkgdown::build_site()
file.exists("inst/pkgdown/logo.png")
pkgdown::build_site()
pkgdown::clean_site()
unlink("docs", recursive = TRUE)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::clean_site()
unlink("docs", recursive = TRUE)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
# dataviewR <a href="https://madhankumarnagaraji.r-universe.dev/dataviewR"><img src="man/figures/dataviewR_logo.png" align="right" height="40" alt="dataviewR logo" /></a>
**An Interactive and Feature-Rich Data Viewer for R**
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
devtools::install()
devtools::load_all()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
